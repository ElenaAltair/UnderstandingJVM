# Задача "Понимание JVM"

### Описание

Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM

Не забудьте упомянуть про:

ClassLoader'ы,
области памяти (стэк (и его фреймы), хип, метаспейс)
сборщик мусора

### Код для исследования

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}

## Ответ

Java Virtual Machine (JVM, Java VM) — виртуальная
машина Java, основная часть исполняющей
системы Java.

ClassLoader'ы - подсистема загрузчиков классов.

У нас есть свой собственный класс  JvmComprehension, который при запуске нашей программы, подсистема загрузчиков классов пытается загрузить. 

В нашем классе естьб два метода: main, принимающий на вход массив строк, и метод printAll, принимающий на вход три параметра, два из них относятся к ссылочному типу данных Object и Integer, и один к приметивному типу int.

И так подсистема загрузчиков классов пытается загрузить наш класс JvmComprehension. Далее мы попадаем в саму подсистему, представляет собой многоуровневую структуру, состоящую из трёх класслоудеров: 
- Bootstrap ClassLoader (отвечает за загрузку классов которые входят в состав ядра Java (базовые классы)),
-  Platform ClassLoader (отвечает за загрузку классов, которые мы подключили откуда-то из вне, например, из сторонних библиотек), 
-  Application ClassLoader (отвечает за классы которые мы напимали сами).
Сначала классы ищутся в Bootstrap ClassLoader, затем в Platform ClassLoader. Если эти класслоудеры ничего не найдут, то классы ищутся уже в Application ClassLoader.

Обнаруженные классы, их методы, поля и значения попадают в Metaspace - область памяти, где хранится мета-информация.

Метод main является точкой входа в нашу программу. В момент обращения к методу у нас в Stack Memory создаётся новый фрейм(кадр), в котором будет фиксироваться вся работа связанная с нашим методом.
В методе main нашего класса JvmComprehension мы инициализируем примитивную переменную i, присваеваем ей значение 1. Так как переменная примитивная, то её значение, хранится в Stack Memory.
Далее создаются объекты:
- new Object(), создание объекта происходит в куче (Heap), для того чтобы обратиться к этому объекта из стека, мы в стеке заводим для него ссылку с именем o и указываем, что эта ссылка ссылается на соответствующий объект в куче.
- Integer, создание объекта происходит в куче (Heap), для того чтобы обратиться к этому объекта из стека, мы в стеке заводим для него ссылку с именем ii  и указываем, что эта ссылка ссылается на соответствующий объект в куче, этой переменной присваивается значение 2. Раз переменная у нас ссылочного типа, то её значение хранится в куче.
  
Далее мы обращаемся к методу printAll нашего класса JvmComprehension, передавая ему на вход три пареметра (На стеке создаётся фрейм для этого метода. На стеке в этом фрейме создаются две ссылки для переменных ссылочного типа, ссылающиеся на ровно такие же объекты, что и соответствующие ссылки в методе main, и переменная примитивного типа, которая будет копией соответствующей примитивной переменной из метода main, пережанных в качестве параметров в метод).  Метод у нас статический, поэтому для обращения к нему не надо создавать объект нашего класса.

В методе printAll,  происходит создание объекта типа Integer в куче (Heap), для того чтобы обратиться к этому объекта из стека, мы в стеке заводим для него ссылку с именем uselessVar  и указываем, что эта ссылка ссылается на соответствующий объект в куче, этой переменной присваивается значение 700. Раз переменная у нас ссылочного типа, то её значение хранится в куче. Эта переменная видна только в пределах метода printAll.
Далее происходит вызов метода System.out.println (на стеке создаётся фрейм для этого метода), который на вход принимает строку и выводит её на экран. При этом происходит создание объекта типа String в куче , на который не будет ссылки. В нашем случае данный строковый объект создаётся так:вызывается метода toString  для объекта o (в стеке создаётся фрейм для этого метода), далее происходит конкатенация данной строки со значением переменной i, которое Java самостоятельно преобразует в строковый тип (раз происходит вызов метода, для преобразования типов, то в стеке создаётся, соответствующий фрейм), и далее идет конкатенация со значение переменной ii, которое также будет преобразовано java в строковый тип (и снова, раз происходит вызов метода, для преобразования типов, то в стеке создаётся, соответствующий фрейм).

Далее мы возвращаемся в наш метод main, вызываем метод System.out.println и выводим на экран строку finished. (на стеке создаётся фрейм для этого метода), который на вход принимает строку и выводит её на экран. При этом происходит создание объекта типа String в куче , на который не будет ссылки.

Объекты, которые больше не используются, собираются сборщиком мусора и удаляются из памяти. Для определения объектов которые не используются, обычно применяется метод обхода графа в поисках достижимых объектов. Соответсвенно, если объекты не достижимы, считается, что они больше не используются и удаляются из памяти.

